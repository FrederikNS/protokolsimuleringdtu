Fixe alle "TODO"s

Færdiggørelse af Sensor-protokolen.
Test af Sensor-protokolen.

Færdiggørelse af XML aflæsning. (25%)
Færdiggørelse af XML indskriving. (50%)
Lave Turn/TurnController classerne.



///---- Sensor revision 164

	protected final boolean isForMe(Transmission msg) {
		return msg.getReceiver() == this.id;
	}
	
	/* (non-Javadoc)
	 * @see transmissions.Transmitter#transmit(transmissions.Transmission)
	 */
	public void transmit(Transmission msg) {
		// TODO Auto-generated method stub
		
	}

	/* (non-Javadoc)
	 * @see turns.Prepareable#prepare()
	 */
	public void prepare() {
		// TODO Auto-generated method stub
		if(0 == ( currentTick & OPTION_SEND_DISABLED)) {
			//Can send.
			if(outgoing == null) {
				//No unhandled outgoing message.
				if(unsentData.size() > 0) {
					//Generate datamessage.
					outgoing = new Transmission(0, 0, unsentData);
					unsentData = null;
				} else {
					//Got absolutely nothing to sent, flag "nothing to do".
					currentTick |= ACTION_NOTHING_TO_DO;
				}
			}
			
			
		}
		
		
	}

	/* (non-Javadoc)
	 * @see turns.Steppable#step()
	 */
	public void step() {
		// TODO Auto-generated method stub
		if(0 != (currentTick & ACTION_NOTHING_TO_DO)) {
			//Nothing to do.
			return;
		}
		if(0 != (currentTick & ACTION_SENDING)) {
			
			if(0 == (currentTick & OPTION_SEND_DISABLED) ) {
				//Can send.
			} else {
				//Cannot send?
			}
		}
	}

	/* (non-Javadoc)
	 * @see turns.EndSteppable#EndStep()
	 */
	public void endStep() {
		// TODO Auto-generated method stub
		if(ingoing != null) {
			switch(ingoing.getMessageType()) {
			case TYPE_DATA: 
				int size = ingoing.size();
				for(int i = 0 ; i < size ; i++) {
					unsentData.add(ingoing.getData(i));
				}
				break;
			case TYPE_NETWORK:
				//Network update. New Sensor appeared or old sensor vanished.
				// No need to reply.
				break;
			case TYPE_RECEIVED_SUCCESSFULLY:
				//Someone received a message successfully.
				if(isForMe(ingoing)) {
					//clear the time-out standing and allow new package to be sent.
					outgoing = null;
				} else if(waiting && ingoing.getSender() == outgoing.getReceiver()) {
					waiting = false;
					//add random delay?
				}
				break;
			case TYPE_RECEIVED_UNSUCCESSFULLY:
				//Someone did not receive their package.
				if(outgoing != null && outgoing.getReceiver() == ingoing.getSender()) {
					//It was the one I sent to recently, clear time-out standing
					if(isForMe(ingoing)) {
						//attempt resend during next tick.
						resendDelay++;//TODO Randomize
					} else {
						//await for a successfully received from sender.
					}				
				}
				break;
			case TYPE_GARBAGE:
				if(0 != (ACTION_RECEIVING & currentTick) ) {
					if(outgoing != null) {
						//Handle having an outgoing message.
					}
				}
				break;
			default:
				//unexpected type. 
				break;
			}
		}
		ingoing = null;
		currentTick = 0;
	}
	
	
	

	